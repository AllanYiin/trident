import inspect
import json
import locale
import os
import platform
import sys
import threading
from collections import OrderedDict
from functools import partial

import numpy as np
from trident.backend import dtype as Dtype

_trident_context=None




def sanitize_path(path):
    """Sanitize the file or folder path, a same-format and absoluted path will return.

    Args:
        path (str): a path of file or folder

    Returns:
        sanitized path

    Examples:
        >>> print(sanitize_path('~/.trident/datasets'))
        C:/Users/allan/.trident/datasets

    """
    if path.startswith('~/'):
        path=os.path.join(os.path.expanduser("~"),path[2:])
    path=os.path.abspath(path)
    return path.strip().replace('\\', '/')
    # if isinstance(path, str):
    #     return os.path.normpath(path.strip()).replace('\\', '/')
    # else:
    #     return path

def split_path(path:str):
    """split path into folder, filename and ext 3 parts clearly.

    Args:
        path (str): a path of file or folder

    Returns:
        folder, filename and ext

    Examples:
        >>> print(split_path('C:/.trident/datasets/cat.jpg'))
        ('C:/.trident/datasets', 'cat', '.jpg')
        >>> print(split_path('C:/.trident/models/resnet.pth.tar'))
        ('C:/.trident/models', 'resnet', '.pth.tar')

    """
    if path is None or len(path) == 0:
        return '', '', ''
    path = sanitize_path(path)
    folder, filename = os.path.split(path)
    ext = ''
    if '.' in filename:
        filename, ext = os.path.splitext(filename)
        # handle double ext, like 'mode.pth.tar'
        if ext in ['.tar', '.pth', '.pkl', '.ckpt', '.bin', '.pt','.zip']:
            filename, ext2 = os.path.splitext(filename)
            ext = ext2 + ext
    else:
        folder = os.path.join(folder, filename)
        filename = ''
    return folder, filename, ext



def make_dir_if_need(path):
    """Check the base folder in input path whether exist, if not , then create it.

    Args:
        path (str): a path of file or folder

    Returns:
        sanitized path

    """
    folder, filename, ext = split_path(path)
    if len(folder) > 0 and not os.path.exists(folder):
        try:
            os.makedirs(folder)
        except Exception as e:
            print(e)
            sys.stderr.write('folder:{0} is not valid path'.format(folder))
    return sanitize_path(path)


def get_sitepackages():  # pragma: no cover
    """!!! note

    Failed to generate docs

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    installed_packages=None
    try:
        import subprocess
        import sys

        reqs = subprocess.check_output([sys.executable, '-m', 'pip', 'freeze'])
        installed_packages = [r.decode().split('==')[0] for r in reqs.split()]
        return installed_packages

    # virtualenv does not ship with a getsitepackages impl so we fallback
    # to using distutils if we can
    # https://github.com/pypa/virtualenv/issues/355
    except Exception as e:
        print(e)
        try:
            from distutils.sysconfig import get_python_lib

            return [get_python_lib()]

        # just incase, don't fail here, it's not worth it
        except Exception:
            return []


class _ThreadLocalInfo(threading.local):
    """
    Thread local Info used for store thread local attributes.
    """

    def __init__(self):
        """!!! note

        Failed to generate docs


        """
        super(_ThreadLocalInfo, self).__init__()
        self._reserve_class_name_in_scope = True

    @property
    def reserve_class_name_in_scope(self):
        """Gets whether to save the network class name in the scope."""
        return self._reserve_class_name_in_scope

    @reserve_class_name_in_scope.setter
    def reserve_class_name_in_scope(self, reserve_class_name_in_scope):
        """Sets whether to save the network class name in the scope."""
        if not isinstance(reserve_class_name_in_scope, bool):
            raise ValueError(
                "Set reserve_class_name_in_scope value must be bool!")
        self._reserve_class_name_in_scope = reserve_class_name_in_scope


class _Context:
    """
    _Context is the environment in which operations are executed
    Note:
        Create a context through instantiating Context object is not recommended.
        should use context() to get the context since Context is singleton.
    """
    _instance = None
    _instance_lock = threading.Lock()

    def __init__(self):
        """Initializes the object.

        Attributes:
            _thread_local_info : an instance of _ThreadLocalInfo
            _context_handle : an ordered dictionary to store context information
            _errors_config : configuration for handling errors

        """
        self._thread_local_info = _ThreadLocalInfo()
        self._context_handle = OrderedDict()
        self._errors_config=None
        self._initial_context()

    def __new__(cls, *args, **kwargs):
        """Create a new instance of the class.

        Args:
            cls: The class being instantiated
            *args: Variable length argument list
            **kwargs: Arbitrary keyword arguments

        Returns:
            The newly created instance of the class

        Note:
            This method is responsible for creating a new instance of the class. It implements a singleton pattern, ensuring that only one instance of the class is created.

        """
        if cls._instance is None:
            cls._instance_lock.acquire()
            cls._instance = object.__new__(cls)
            cls._instance_lock.release()
        return cls._instance

    def _get_trident_dir(self):
        """Get or create trident directory
        1)  read from enviorment variable 'TRIDENT_HOME'
        2) use default directory '~/.trident'
        3) if the directory not exist, create it!

        Returns:
            the  trident directory path

        """
        _trident_dir = ''
        if 'TRIDENT_HOME' in os.environ:
            _trident_dir = os.environ.get('TRIDENT_HOME')
        else:
            _trident_base_dir = os.path.expanduser('~')
            if not os.access(_trident_base_dir, os.W_OK):
                _trident_dir = '/tmp/.trident'
            else:
                _trident_dir = os.path.expanduser('~/.trident')

        _trident_dir = sanitize_path(_trident_dir)
        if not os.path.exists(_trident_dir):
            try:
                os.makedirs(_trident_dir)
            except OSError as e:
                # Except permission denied and potential race conditions
                # in multi-threaded environments.
                print(e)

        return _trident_dir

    def _get_plateform(self):
        """

        Returns:
            check current system os plateform.

        """
        plateform_str = platform.system().lower()
        if 'darwin' in plateform_str:
            return 'mac'
        elif 'linux' in plateform_str:
            return 'linux'
        elif 'win' in plateform_str:
            return 'windows'
        else:
            return plateform_str

    def _initial_context(self):
        """Initializes the context for the Trident framework.

        Attributes:
            _module_dict : dictionary to store module information
            trident_dir : directory path for Trident
            backend : backend framework (e.g., TensorFlow, PyTorch, JAX)
            print : function to print with flush
            is_tensorboard_available : flag indicating if TensorBoard is available
            is_tensorflow_available : flag indicating if TensorFlow is available
            is_jax_available : flag indicating if JAX is available
            is_pytorch_available : flag indicating if PyTorch is available
            is_numba_available : flag indicating if Numba is available
            is_tensorboard_available : flag indicating if TensorBoard is available
            is_mlflow_available : flag indicating if MLflow is available
            enable_tensorboard : flag indicating if TensorBoard is enabled
            summary_writer : summary writer for TensorBoard
            mlflow_logger : MLflow logger
            enable_mlflow : flag indicating if MLflow is enabled
            locale : default locale
            image_backend : image backend (e.g., OpenCV)
            epoch_equivalent : equivalent number of epochs
            floatx : floating point precision
            epsilon : small value for numerical stability
            working

        """
        self._module_dict = dict()
        self.trident_dir = self._get_trident_dir()
        self.backend =None
        self.print=partial(print,flush=True)
        site_packages=get_sitepackages()

        self.is_tensorboard_available=False
        self.is_tensorflow_available = False
        self.is_jax_available = False
        self.is_pytorch_available = False
        self.is_numba_available = False
        self.is_tensorboard_available = False
        self.is_mlflow_available = False
        if 'tensorboard' in site_packages:
            self.is_tensorboard_available=True
        if 'tensorboard' in site_packages:
            self.is_tensorboard_available=True
        if 'jax' in site_packages:
            self.is_jax_available=True
        if 'torch' in site_packages:
            self.is_pytorch_available=True
        if 'cupy' in site_packages:
            self.is_cupy_available=True
        if 'mlflow' in site_packages:
            self.is_mlflow_available = True

        self.enable_tensorboard=False
        self.summary_writer=None
        self.mlflow_logger = None
        self.enable_mlflow = False


        self.locale = locale.getdefaultlocale()[0] if  locale.getdefaultlocale() else None

        self.image_backend = 'opencv'
        self.epoch_equivalent = 1000
        self.floatx = 'float32'
        self.epsilon = 1e-7
        self.working_directory = os.getcwd()
        self.plateform = self._get_plateform()
        self.numpy_print_format = '{0:.4e}'
        self.amp_available = False
        self.is_autocast_enabled = False


        self.tensorboard_server='localhost'
        self.tensorboard_port =6006
        self.mlflow_server = 'localhost'
        self.mlflow_port = 5000

        if 'COLAB_TPU_ADDR' in os.environ:
            self.tpu_address = 'grpc://' + os.environ['COLAB_TPU_ADDR']
            print('TPU is available.')

        _config_path = os.path.expanduser(os.path.join(self.trident_dir, 'trident.json'))
        _config = {}

        if os.path.exists(_config_path):
            try:
                with open(_config_path) as f:
                    _config = json.load(f)
                    for k, v in _config.items():
                        try:
                            if k == 'floatx':
                                assert v in {'float16', 'float32', 'float64'}
                            if k not in ['trident_dir', 'device', 'working_directory']:
                                self.__setattr__(k, v)
                        except Exception as e:
                            print(e)
            except ValueError as ve:
                print(ve)
        if 'TRIDENT_WORKING_DIR' in os.environ:
            self.working_directory = os.environ['TRIDENT_WORKING_DIR']
            os.chdir(os.environ['TRIDENT_WORKING_DIR'])


        if 'TRIDENT_BACKEND' in os.environ:
            if self.backend != os.environ['TRIDENT_BACKEND']:
                self.backend = os.environ['TRIDENT_BACKEND']

        if not hasattr(self,'backend') or self.backend is None:
            try:
                import torch
                os.environ['TRIDENT_BACKEND'] = 'pytorch'
            except:
                try:
                    import tensorflow
                    os.environ['TRIDENT_BACKEND'] = 'tensorflow'
                except:
                    try:
                        import jax
                        os.environ['TRIDENT_BACKEND'] = 'jax'
                    except:
                        pass
        np.set_printoptions(formatter={'float_kind': lambda x: self.numpy_print_format.format(x)},precision=4,suppress=True)
        self.device = None


    def __getattribute__(self, attr):
        """Get the value of an attribute.

        Args:
            attr: the name of the attribute to get

        Returns:
            The value of the attribute

        Raises:
            ValueError: If the attribute is "_context_handle" and its value is None

        """
        value = object.__getattribute__(self, attr)
        if attr == "_context_handle" and value is None:
            raise ValueError("Context handle is none in context!!!")
        return value

    @property
    def float_dtype(self):
        """Return the floating point dtype currently used by the backend.

        The value is determined by :attr:`floatx` and will switch to
        ``float16`` automatically when automatic mixed precision is enabled on
        CUDA devices.
        """
        device = getattr(self, 'device', None)
        dtype = getattr(Dtype, self.floatx)
        if self.amp_available and self.is_autocast_enabled and device == 'cuda':
            return Dtype.float16
        else:
            return dtype

    @property
    def module_dict(self):
        """!!! note

        Failed to generate docs


        """
        return self._module_dict

    def get_module(self, cls_name, module_name='module'):
        """Get the registry record.
        Args:
            module_name ():
            cls_name ():
        Returns:
            class: The corresponding class.
        """
        if module_name not in self._module_dict:
            raise KeyError('{module_name} is not in registry')
        dd = self._module_dict[module_name]
        if cls_name not in dd:
            raise KeyError('{cls_name} is not registered in {module_name}')

        return dd[cls_name]

    def _register_module(self, cls, module_name):
        """Registers a class in a module.

        Args:
            cls: The class to be registered.
            module_name: The name of the module.

        Raises:
            TypeError: If cls is not a class.
            KeyError: If cls is already registered in the module.

        """
        if not inspect.isclass(cls):
            raise TypeError('module must be a class, ' 'but got {type(cls)}')

        cls_name = cls.__name__
        self._module_dict.setdefault(module_name, dict())
        dd = self._module_dict[module_name]
        if cls_name in dd:
            raise KeyError('{cls_name} is already registered '
                           'in {module_name}')
        dd[cls_name] = cls

    def register_module(self, module_name='module'):

        """Register a module.

        Args:
            module_name (str): Name of the module (default: 'module')

        Returns:
            The decorated class

        Note:
            This function is a decorator that can be used to register a class as a module.

        """
        def _register(cls):
            """Registers a class.

            Args:
                cls: The class to be registered

            Returns:
                The registered class
            !!! note

                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
            """
            self._register_module(cls, module_name)
            return cls

        return _register

    def get_backend(self):
        """!!! note

        Failed to generate docs


        """
        return self.backend

    def try_enable_tensorboard(self, summary_writer):
        """Enable TensorBoard for logging.

        Args:
            summary_writer: Summary writer object for TensorBoard logging.

        """
        self.enable_tensorboard=True
        self.summary_writer = summary_writer

    def try_enable_mlflow(self,mlflow_logger):
        """Enable MLflow for logging.

        Args:
            mlflow_logger: MLflow logger object

        Returns:
            None

        """
        self.enable_mlflow=True
        self.mlflow_logger = mlflow_logger

    def regist_data_provider(self,data_provider ):
        """Registers a data provider.

        Args:
            data_provider: The data provider to be registered.

        """
        if not hasattr(self._thread_local_info,'data_providers'):
            self._thread_local_info.data_providers=OrderedDict()
        self._thread_local_info.data_providers[getattr(data_provider,'uuid')]=data_provider

    def get_data_provider(self,name=None):
        """Get a data provider.

        Args:
            name (str, optional): Name of the data provider. If not provided, returns a list of all data providers.

        Returns:
            If name is provided, returns the data provider with the matching name.
            If name is not provided, returns a list of all data providers.

        Raises:
            None.

        """
        if name is None:
            return list(self._thread_local_info.data_providers.values())
        else:
            for dp in self._thread_local_info.data_providers.values():
                if dp.name==name:
                    return dp

    def regist_resources(self,resource_name,resource ):
        """Registers a resource.

        Args:
            resource_name: Name of the resource
            resource: The resource to be registered

        Returns:
            The registered resource

        """
        if not hasattr(self._thread_local_info,'resources'):
            self._thread_local_info.resources=OrderedDict()
        self._thread_local_info.resources[resource_name]=resource
        return self._thread_local_info.resources[resource_name]

    def get_resources(self,resource_name):
        """Get a resource by name.

        Args:
            resource_name: Name of the resource to get.

        Returns:
            The resource with the given name, or None if it doesn't exist.

        Note:
            This function uses thread-local storage to store the resources.

        """
        if not hasattr(self._thread_local_info, 'resources'):
            self._thread_local_info.resources = OrderedDict()
        if resource_name in self._thread_local_info.resources:
            return self._thread_local_info.resources[resource_name]
        else:
            return None








def _context():
    """
    Get the global _context, if context is not created, create a new one.
    Returns:
        _Context, the global context in PyNative mode.
    """
    global _trident_context
    if _trident_context is None:
        _trident_context = _Context()
    return _trident_context
